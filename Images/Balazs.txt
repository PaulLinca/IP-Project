#include "stdafx.h"
#include "common.h"
#include <vector>
#include <iostream>
#include <fstream>

using namespace std;

typedef struct _border
{
	vector<Point2i> borderPoints;
	vector<int> chainCodes;
}BORDER;

typedef struct _reconstruct
{
	Point2i startPoint;
	vector<int> chainCode;
}RECONSTRUCT;

Point2i GetTraceStart(Mat *img)
{
	int h = img->rows, w = img->cols;

	for (int i = 0; i < h; i++)
	{
		for (int j = 0; j < w; j++)
		{
			if (img->at<uchar>(i, j) == 0)
			{
				cout << "i=" << i << endl;
				cout << "j=" << j << endl;
				return Point2i(j, i);
			}
		}
	}
	return Point2i(-1, -1);
}

Point2i dirPixel(Point2i start, int dir)
{
	switch (dir)
	{
	case 0: return Point2i(start.x + 1, start.y);
	case 1: return Point2i(start.x + 1, start.y - 1);
	case 2: return Point2i(start.x, start.y - 1);
	case 3: return Point2i(start.x - 1, start.y - 1);
	case 4: return Point2i(start.x - 1, start.y);
	case 5: return Point2i(start.x - 1, start.y + 1);
	case 6: return Point2i(start.x, start.y + 1);
	case 7: return Point2i(start.x + 1, start.y + 1);
	default: return Point2i(-1, -1);
	}
}

BORDER BorderTracing(Mat *img, Point2i startPoint)
{
	BORDER border;
	
	int h = img->rows, w = img->cols;
	int dir = 7;
	Point2i nextPoint(-1, -1);
	Point2i prevPoint = startPoint;

	border.borderPoints.push_back(startPoint);

	do
	{
		if (dir % 2 == 0)
		{
			dir = (dir + 7) % 8;
		}
		else
		{
			dir = (dir + 6) % 8;
		}
		nextPoint = dirPixel(prevPoint, dir);
		while (img->at<uchar>(nextPoint.y, nextPoint.x) != 0)
		{
			dir = (dir + 1) % 8;
			nextPoint = dirPixel(prevPoint, dir);
		}
		border.borderPoints.push_back(nextPoint);
		border.chainCodes.push_back(dir);
		prevPoint = nextPoint;
	} while (border.borderPoints.size() < 4 ||
		border.borderPoints.at(0) != border.borderPoints.at(border.borderPoints.size() - 2) ||
		border.borderPoints.at(1) != border.borderPoints.at(border.borderPoints.size() - 1));

	// Removing 2 leftover points.
	border.borderPoints.pop_back();
	border.borderPoints.pop_back();
	border.chainCodes.pop_back();
	border.chainCodes.pop_back();

	return border;
}

vector<int> chainCodeToDerivativeChainCode(vector<int> chainCode)
{
	vector<int> derivative;
	size_t chainSize = chainCode.size();

	for (size_t i = 1; i < chainSize; i++)
	{
		int derivPoint = (chainCode.at(i) - chainCode.at(i - 1) + 8) % 8;
		derivative.push_back(derivPoint);
	}

	return derivative;
}

Mat ReconstructBorder(Mat *src, RECONSTRUCT *recon, uchar borderCol)
{
	Mat img = Mat(src->rows, src->cols, CV_8UC1);
	img = src->clone();
	Point2i prevPoint = recon->startPoint;
	img.at<uchar>(prevPoint.y, prevPoint.x) = borderCol;

	for (auto i : recon->chainCode)
	{
		Point2i nextPoint = dirPixel(prevPoint, i);
		img.at<uchar>(nextPoint.y, nextPoint.x) = borderCol;
		prevPoint = nextPoint;
	}
	return img;
}

void borderRunner()
{
	char fname[MAX_PATH];

	while (openFileDlg(fname))
	{
		Mat img = imread(fname, CV_LOAD_IMAGE_GRAYSCALE);

		Point2i start = GetTraceStart(&img);
		cout << start.x << ',' << start.y << endl;

		BORDER border = BorderTracing(&img, start);

		cout << border.chainCodes.size() << endl;
		for (auto i : border.chainCodes)
			cout << i << ", ";
		cout << endl;
		vector<int> derivative = chainCodeToDerivativeChainCode(border.chainCodes);
		for (auto i : derivative)
			cout << i << ", ";

		RECONSTRUCT recon = { start, border.chainCodes };

		Mat overlay = Mat::zeros(img.rows, img.cols, CV_8UC1);
		Mat dst = ReconstructBorder(&overlay, &recon, 255);

		imshow("img", img);
		imshow("dst", dst);
		waitKey(0);
	}
}

RECONSTRUCT readFromFile(char *fname)
{
	RECONSTRUCT recon;

	ifstream stream(fname, ios::in);

	stream >> recon.startPoint.x;
	stream >> recon.startPoint.y;

	int n = 0, rd;
	stream >> n;
	for (int i = 0; i < n; i++)
	{
		stream >> rd;
		recon.chainCode.push_back(rd);
	}

	return recon;
}

void fromFile()
{
	char fname[MAX_PATH];
	char fname2[MAX_PATH];
	while (openFileDlg(fname))
	{
		 RECONSTRUCT recon = readFromFile(fname);
		 
		 openFileDlg(fname2);
		 Mat backg = imread(fname2, CV_LOAD_IMAGE_GRAYSCALE);
		 Mat dst = ReconstructBorder(&backg, &recon, 0);

		 imshow("dst", dst);
		 waitKey(0);
	}
}